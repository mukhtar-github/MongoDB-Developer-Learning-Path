sudo systemctl start mongod
sudo systemctl status mongod
sudo systemctl stop mongod

mongo --port 27000.
mongoimport --db mongo-exercises --collection courses --drop --file exercise-data.json --jsonArray

** dkemg
mongo "mongodb+srv://cluster0.dkemg.mongodb.net/admin" --username m001-student
** m001-mongodb-basics
mongodb+srv://m001-student:m001-mongodb-basics@cluster0.dkemg.mongodb.net/test



# Just do those two commands for temporary solution:
$ sudo rm -rf /tmp/mongodb-27017.sock
$ sudo service mongod start
# That shall be fault due to user permissions in .sock file, You may have to change the owner to monogdb user.

chown -R mongodb:mongodb /var/lib/mongodb
chown mongodb:mongodb /tmp/mongodb-27017.sock


sudo rm -r /var/mongodb
sudo mkdir -p /var/mongodb/pki/
sudo chown vagrant:vagrant -R /var/mongodb/pki/
openssl rand -base64 741 > /var/mongodb/pki/m103-keyfile
chmod 400 /var/mongodb/pki/m103-keyfile
ls -l /var/mongodb/pki
ls -l /var/mongodb

cat /var/mongodb/pki/m103-keyfile
sudo mkdir -p /var/mongodb/db/node1
chown -R mongodb.mongodb ~/var/mongodb/db/node1
mongod -f /shared/node1.conf

~~~
vagrant --global-status --prune
*** Bring up a virtual machine
cd vagrant@m103
vagrant up
*** SSH into the machine
vagrant ssh
vagrant@vagrant:~$ logout
Connection to 127.0.0.1 closed.


sudo systemctl stop mongod.service
sudo systemctl start mongod.service
sudo systemctl enable mongod.service
sudo systemctl status mongod.service
sudo apt update


storage:
  dbPath: /var/mongodb/db/node1
net:
  bindIp: localhost
  port: 27017
security:
  authorization: enabled
  keyFile: /var/mongodb/pki/m103-keyfile
systemLog:
  destination: file
  path: /var/mongodb/db/node1/mongod.log
  logAppend: true
processManagement:
  fork: true
replication:
  replSetName: m103-example

*** Checking which mongo processes are running and on which port: ps -ef | grep "[m]ongo"

// start with
sudo mongod -f csrs_1.conf
sudo mongod -f csrs_2.conf
sudo mongod -f csrs_3.conf
sudo mongos -f mongos.conf
mongo --port 26000 --username m103-admin --password m103-pass --authenticationDatabase admin

// followed by
sudo mongod -f node1.conf
sudo mongod -f node2.conf
sudo mongod -f node3.conf
mongo --host "m103-example/localhost:27011" -u "m103-admin" -p "m103-pass" --authenticationDatabase "admin"

* Adding new nodes to  my repSet
cp node3.conf node4.conf
sudo mkdir -p /var/mongodb/db/node4
sudo mongod -f node4.conf
rs.add("localhost:27012")
sudo mongod -f arbiter.conf
rs.addArb("localhost:28000")
rs.remove("localhost:28000")

** If you'd like to deploy a sharded cluster on your machine, you can find the commands from the lecture here:
vagrant@vagrant:~$ vim csrs_1.conf
vagrant@vagrant:~$ sudo mkdir -p /var/mongodb/db/csrs1
Starting the three config servers:
vagrant@vagrant:~$ sudo mongod -f csrs_1.conf
about to fork child process, waiting until server is ready for connections.
forked process: 1494
child process started successfully, parent exiting

rm -r repl_set
rmdir (filename)
mongos> cls -- for clear screen

db.createCollection(name, options)

db.getCollection('products').findOneAndUpdate(
  { "_id" : ObjectId("61406480013e1d1da41a69df") },
  { $push: { "sku" : 1000 } }
)

mongoimport /dataset/products.json --port 26000 -u m103-admin -p m103-pass --authenticationDatabase admin -d m103 --collection products
mongoimport --drop --port 27000 -u m103-application-user -p m103-application-pass --authenticationDatabase admin -d applicationData -c applicationData.products --file "/dataset/products.json"
mongoimport --db applicationData --collection products --port 27000 -u m103-application-user -p m103-application-pass --authenticationDatabase admin --file /dataset/products.json
mongo --port 27000 -u m103-admin -p m103-pass --authenticationDatabase admin


sudo mkdir -p /var/mongodb/db/companies_1.json
vim companies_1.json
mongoimport companies_1.json --port 26000 -u m103-admin -p m103-pass --authenticationDatabase admin -d m103 --collection companies
mongoimport companies_1.json --drop --port 26000 -u m103-admin -p m103-pass --authenticationDatabase admin -d m103 --collection companies --jsonArray


db.products.insert(
  {
    "sku" : 1000000749,
    "name" : "MTG products",
    "type" : "Sofware",
    "regularPrice" : 39.95,
    "salePrice" : 39.95,
    "shippingWeight" : "0.01"
  }
)

db.products.remove()
sudo mkdir -p /var/mongodb/db/products_2.json
mongoimport products_2.json --drop --port 26000 -u "m103-admin" -p "m103-pass" --authenticationDatabase "admin" --db m103 --collection products
vim -r products_2.json
ls


***
mongo "mongodb://cluster0-shard-00-00-jxeqq.mongodb.net:27017,cluster0-shard-00-01-jxeqq.mongodb.net:27017,cluster0-shard-00-02-jxeqq.mongodb.net:27017/aggregations?replicaSet=Cluster0-shard-0" --authenticationDatabase admin --ssl -u m121 -p aggregations --norc


mukhtar@mukhtar-Aspire-ES1-431:~$ vim validateLab1.js
mukhtar@mukhtar-Aspire-ES1-431:~$ sudo mkdir -p /var/m121/validateLab1.js
mukhtar@mukhtar-Aspire-ES1-431:~$ vim validateLab2.js
mukhtar@mukhtar-Aspire-ES1-431:~$ sudo mkdir -p /var/m121/validateLab2.js
mukhtar@mukhtar-Aspire-ES1-431:~$ cat /var/m121/validateLab1.js
cat: /var/m121/validateLab1.js: Is a directory
cd /var/m121


sudo vim /etc/environment
source /etc/environment
echo $JAVA_HOME
sudo mkdir -p /etc/environment
vim -r /etc/environment
:term
Ctrl-W N

:vert term
:set makeprg=javac\ -g\ /etc/environment
:copen
=expand('%:r') => brings out current file name


To paste in the Vim Editor, use "+p then paste.
To create a new file vim (filename)
:wq or :x or ZZ - write (save) and quit

Long story short: If at all possible, use "*P or "+P to paste 
(which even works in some terminal emulators if I recall correctly).
This is the "correct" way to paste; everything else is basically a workaround gives you those kinds of headaches.

You can explore your current directory by hitting :Ex.
This will show a list view of your files and you can navigate up (j) or down (k) with the usual methods.
You can also delete a file by hitting: SHIFT + D and confirming with y.
To go back to editing, select the file and hit ENTER.

How do I delete a vim file in Terminal?
You can do it with two steps:
save as a new file. :w newfilename.
delete the old file. ! rm oldfilename.

! rm companies_dataset/companies.json
cat /var/m121/validateLab1.js
/var/mongodb/db/companies.json


If you want to select all of the text using Vim then use ggVGy (note the uppercase VG in the middle). This command moves
the cursor to the top of the file, enters visual mode, moves to the bottom of the file (thus, selecting all of the text)
and then yanks (copies) it. You can then use p to put (paste) this code but only inside of Vim.

If you want to copy to the clipboard to use somewhere outside of Vim then try this:
First, select everything using the commands outlined above but without the final y: (ggVG). Then press "*y or "+y. This should
now copy it to your operating system's clipboard and you can just paste (Ctrl/Cmd+v) anywhere you want outside of Vim.
This can vary depending on what settings you have for Vim but it should work.
:%y +

Or you can install jq which is faster (written in C) from your package manager
(e.g. sudo apt install jq in Ubuntu/Debian, and then in vim, type: (:%!jq .)

# Git Kraken SSH
# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCspFEoEmcBA+pzgnACYfc+OF373j3Da+HGzYY5THXfuLZnSWvYbUX21oYGC6yoObPJ7nR/mrgAgxJ/NEqco1uOuHY4b95KIIBdiQ0qOIY7RaWASJqhdkLPUkWQG57TLupD6RmrVO6k3nMXOz2pmSQlTK8VmpseIkiHjVdBJVcXATwQS8wP2seQl89O0fL5OJ/zOVBIJF8iAtvwhAHE7vQ4nwwrm9Bz4NmLhBBQOZFCMPxVWfeVpQcKt/xa46uWRqc9Q1y4vc1GmUGTswRACHU52GfgpBSQgPC+WQRZpfR16aE9Dxhxb9buALRtB55O0M1hmZh7fJ+bWKgI3eNtuepr 


# M220JS: MongoDB for JavaScript Developers
# Ticket: Connection
# Rename this file to .env after filling in your MFLIX_DB_URI and your SECRET_KEY
# Do not surround the URI with quotes
# SECRET_KEY=super_secret_key_is_changed_to_mukhtar_tanimu_garba
# MFLIX_DB_URI=mongodb+srv://m220student:m220password@mflix.sa8ij.mongodb.net/test
# MFLIX_NS=sample_mflix
# PORT=5000
# http://localhost:5000/
# mongosh mongodb+srv://mflix.sa8ij.mongodb.net/mflix --username m220student
# tree -L 1 (sudo snap install tree)


**Configuring ignored files for a single repository**
Open Terminal.
Navigate to the location of your Git repository.
Create a .gitignore file for your repository.
$ touch .gitignore
If you want to ignore a file that is already checked in,
you must untrack the file before you add a rule to ignore it. From your terminal,
untrack the file.
$ git rm --cached FILENAME
**Configuring ignored files for all repositories on your computer**
Open Terminal.
Configure Git to use the exclude file ~/.gitignore_global for all Git repositories.
$ git config --global core.excludesfile ~/.gitignore_global

move up a level in your directory tree and create a new folder named *cloned_locator*
in the same directory level as *locator*:
cd ..
mkdir cloned_locator

*** Starting Vagrant ... 8/12/2021
(VBoxManage --version
WARNING: The vboxdrv kernel module is not loaded. Either there is no module
         available for the current kernel (5.11.0-41-generic) or it failed to
         load. Please recompile the kernel module and install it by
           sudo /sbin/vboxconfig
)
> cd vagrant@m103
> sudo systemctl start mongod.service
> vagrant up
(default: SSH address: 127.0.0.1:2222
  default: SSH username: vagrant
  default: SSH auth method: private key)
> vagrant ssh

*** Initial Server Setup with Ubuntu 18.04

> Step 1 — Logging in as Root
ssh root@46.101.63.136 -- your_server_ip (Digital-Ocean-Droplet)
(The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:uY6GIjFdI9qTC4QYb980QRk+WblJF9cd5glr3SmmL+w.
Are you sure you want to continue connecting (yes/no)?)
*Type (exit .) This will logout the super user and go back to your account. If you run (sudo su),
that will open a shell as the superuser. Type (exit or Ctrl - D) to exit this shell.*
> sudo vim /etc/ssh/sshd_config
> vagrant ssh root-psswd -- 0759@vm

> Step 2 — Creating a New User
# adduser mtg
> Enter a strong password -- 0759@vmuser

> Step 3 — Granting Administrative Privileges
# usermod -aG sudo mtg

> Step 4 — Setting Up a Basic Firewall
Run the following command to get a list of all current available profiles:
# ufw app list
// Output
Available applications:
  OpenSSH
You need to make sure that the firewall allows SSH connections so that you can log back in next time.
You can allow these connections by typing:
# ufw allow OpenSSH
Afterwards, you can enable the firewall with:
# ufw enable
Type “y” and press ENTER to proceed. You can see that SSH connections are still allowed by typing:
# ufw status
As the firewall is currently blocking all connections except for SSH, if you install and configure additional services,
you will need to adjust the firewall settings to allow acceptable traffic in.
You can learn some common UFW operations in this guide.

> Step 5 — Enabling External Access for Your Regular User
(SSH, or Secure Shell, is a remote administration protocol that allows users to control and 
modify their remote servers over the Internet. ... It provides a mechanism for authenticating a remote user,
transferring inputs from the client to the host, and relaying the output back to the client.)
The process for configuring SSH access for your new user depends on whether your server’s root account uses a
password or SSH keys for authentication.

If the Root Account Uses Password Authentication
If you logged in to your root account using a password, it means that password authentication is enabled for SSH.
You can SSH to your new user account by opening up a new terminal session and using SSH with your new username:

$ ssh mtg@127.0.0.1

After entering your regular user’s password, you will be logged in. Remember, if you need to run a command
with administrative privileges, type sudo before it like this: sudo (command_to_run)

*** How To Install Nginx on Ubuntu 18.04

> Since this may be your first interaction with the apt packaging system in this session, update the local package index
so that you have access to the most recent package listings. Afterward, you can install nginx:

$ sudo apt update
$ sudo apt install nginx

> Step 2 – Adjusting the Firewall
Before testing Nginx, the firewall software needs to be adjusted to allow access to the service. Nginx registers itself as a service with ufw upon installation, making it straightforward to allow Nginx access.

List the application configurations that ufw knows how to work with by typing the following:
$ sudo ufw app list

Output
Available applications:
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
  OpenSSH

This list displays three profiles available for Nginx:

Nginx Full: This profile opens both port 80 (normal, unencrypted web traffic) and port 443 (TLS/SSL encrypted traffic)
Nginx HTTP: This profile opens only port 80 (normal, unencrypted web traffic)
Nginx HTTPS: This profile opens only port 443 (TLS/SSL encrypted traffic)
It is recommended that you enable the most restrictive profile that will still allow the traffic you’ve configured. Since you haven’t configured SSL for your server yet in this guide, you’ll only need to allow traffic on port 80.

You can enable this by typing the following:
$ sudo ufw allow 'Nginx HTTP'
Then, verify the change:
$ sudo ufw status
You should receive a list of HTTP traffic allowed in the output:

Output
Status: active

To                         Action      From
--                         ------      ----
OpenSSH                    ALLOW       Anywhere                  
Nginx HTTP                 ALLOW       Anywhere                  
OpenSSH (v6)               ALLOW       Anywhere (v6)             
Nginx HTTP (v6)            ALLOW       Anywhere (v6)

Now that you’ve added the appropriate firewall rule,
you can check that your web server is running and able to serve content correctly.

> Step 3 – Checking your Web Server
At the end of the installation process, Ubuntu 18.04 starts Nginx. The web server should already be up and running.
Check with the systemd init system to make sure the service is running:
$ systemctl status nginx

> Step 4 – Managing the Nginx Process
To stop your web server, type the following:
$ sudo systemctl stop nginx
To start the web server when it is stopped, type the following:
$ sudo systemctl start nginx
To stop and then start the service again, type the following:
$ sudo systemctl restart nginx
If you are simply making configuration changes, you can often reload Nginx
without dropping connections instead of restarting it. To do this, type the following:
$ sudo systemctl reload nginx
By default, Nginx is configured to start automatically when the server boots.
If this is not what you want, you can disable this behavior by typing the following:
$ sudo systemctl disable nginx
To re-enable the service to start up at boot, you can type the following:
$ sudo systemctl enable nginx

> Step 5 – Setting Up Server Blocks (Recommended)
When using the Nginx web server, server blocks (similar to virtual hosts in Apache) can be used to encapsulate
configuration details and host more than one domain from a single server.
We will set up a domain called your_domain, but you should replace this with your own domain name.

Nginx on Ubuntu 18.04 has one server block enabled by default that is configured to serve documents
out of a directory at /var/www/html. While this works well for a single site, it can become unwieldy if you are hosting
multiple sites. Instead of modifying /var/www/html, let’s create a directory structure within /var/www for our
your_domain site, leaving /var/www/html in place as the default directory to be served if a client request doesn’t
match any other sites.

Create the directory for your_domain as follows, using the -p flag to create any necessary parent directories:
$ sudo rm -r /var/www/your_domain/html
$ sudo mkdir -p /var/www/mymtg.live/html

Next, assign ownership of the directory with the $USER environment variable:

$ sudo chown -R $USER:$USER /var/www/mymtg.live/html

The permissions of your web roots should be correct if you haven’t modified your (umask) value,
but you can make sure by typing the following:

$ sudo chmod -R 755 /var/www/mymtg.live

Next, create a sample index.html page using vim or your favorite editor:

$ vim /var/www/mymtg.live/html/index.html

Inside, add the following sample HTML:

<html>
    <head>
        <title>Welcome to mymtg.live!</title>
    </head>
    <body>
        <h1>Success! The mymtg.live server block is working!</h1>
    </body>
</html>

In order for Nginx to serve this content, it’s necessary to create a server block with the correct directives.
Instead of modifying the default configuration file directly,
make a new one at /etc/nginx/sites-available/your_domain:

$ sudo vim /etc/nginx/sites-available/mymtg.live

Add the following configuration block, which is similar to the default,
but updated for your new directory and domain name:

server {
        listen 80;
        listen [::]:80;

        root /var/www/mymtg.live/html;
        index index.html index.htm index.nginx-debian.html;

        server_name mymtg.live www.mymtg.live;

        location / {
                try_files $uri $uri/ =404;
        }
}

Notice that we’ve updated the (root) configuration to the new directory,
and the (server_name) to the domain name. Save and close the file when you are finished.

Next, enable the file by creating a link from it to the (sites-enabled) directory, which Nginx reads from during startup:

$ sudo ln -s /etc/nginx/sites-available/mymtg.live /etc/nginx/sites-enabled/

Two server blocks are now enabled and configured to respond to requests based on their (listen) and (server_name)
directives (you can read more about how Nginx processes these directives):

* (mymtg.live): Will respond to requests for (mymtg.live) and www.(mymtg.live).
* (default): Will respond to any requests on port (80) that do not match the other two blocks.

To avoid a possible hash bucket memory problem that can arise from adding additional server names,
it is necessary to adjust a single value in the (/etc/nginx/nginx.conf) file. Open the file:

$ sudo vim /etc/nginx/nginx.conf

Find the (server_names_hash_bucket_size) directive and remove the (#) symbol to uncomment the line:

...
http {
    ...
    server_names_hash_bucket_size 64;
    ...
}
...

Next, test to make sure that there are no syntax errors in any of your Nginx files:

$ sudo nginx -t

If there aren’t any problems, restart Nginx to enable your changes:

$ sudo systemctl restart nginx

Nginx should now be serving your domain name. You can test this by navigating to http://mymtg.live,
where you should see something like the following:

curl -4 127.0.0.1

sudo vim /etc/hosts

> Step 6 – Getting Familiar with Important Nginx Files and Directories
Now that you know how to manage the Nginx service itself, you should take a few minutes to familiarize yourself
with a few important directories and files.

> Content
(/var/www/html): The actual web content, which by default only consists of the default Nginx page you saw earlier,
is served out of the (/var/www/html) directory. This can be changed by altering Nginx configuration files.

> Server Configuration
(/etc/nginx): The Nginx configuration directory. All of the Nginx configuration files reside here.

(/etc/nginx/nginx.conf): The main Nginx configuration file. This can be modified to make changes to the
Nginx global configuration.

(/etc/nginx/sites-available/): The directory where per-site server blocks can be stored. Nginx will not use the
configuration files found in this directory unless they are linked to the (sites-enabled) directory.
Typically, all server block configuration is done in this directory, and then enabled by linking to the other directory.

(/etc/nginx/sites-enabled/): The directory where enabled per-site server blocks are stored.
Typically, these are created by linking to configuration files found in the sites-available directory.

(/etc/nginx/snippets): This directory contains configuration fragments that can be included elsewhere in the
Nginx configuration. Potentially repeatable configuration segments are good candidates for refactoring into snippets.

> Server Logs
(/var/log/nginx/access.log): Every request to your web server is recorded in this log file
unless Nginx is configured to do otherwise.

(/var/log/nginx/error.log): Any Nginx errors will be recorded in this log.


*** How To Secure Nginx with Let's Encrypt on Ubuntu 18.04

> Step 1 — Installing Certbot
The first step to using Let’s Encrypt to obtain an SSL certificate is to install the Certbot software on your server.

The Certbot project recommends that most users install the software through snap, a package manager originally
developed by Canonical (the company behind Ubuntu) and now available on many Linux distributions:

$ sudo snap install --classic certbot

Next, create a symbolic link to the newly installed /snap/bin/certbot executable from the /usr/bin/ directory.
This will ensure that the certbot command can run correctly on your server. To do this, run the following ln command.
This contains the -s flag which will create a symbolic or soft link, as opposed to a hard link:

$ sudo ln -s /snap/bin/certbot /usr/bin/certbot

> Step 2 — Confirming Nginx’s Configuration
Certbot needs to be able to find the correct (server) block in your Nginx configuration for it to be able to automatically
configure SSL. Specifically, it does this by searching for a (server_name) directive that matches the domain you request a
certificate for.

$  sudo vim /etc/nginx/sites-available/mymtg.live

Certbot can now find the correct server block and update it.

> Step 3 — Allowing HTTPS Through the Firewall
If you have the (ufw) firewall enabled, as recommended by the prerequisite guides, you’ll need to adjust the settings to
allow for HTTPS traffic. Luckily, Nginx registers a few profiles with (ufw) upon installation.

You can check the current setting by running the following:

$ sudo ufw status

To let in additional HTTPS traffic, allow the (Nginx Full) profile and delete the redundant (Nginx HTTP) profile allowance:

$ sudo ufw allow 'Nginx Full'
$ sudo ufw delete allow 'Nginx HTTP'

Now when you run the ufw status command it will reflect these new rules:

$ sudo ufw status

Next, you’ll run Certbot and fetch your certificates.

$ sudo certbot --nginx -d mymtg.live -d mymtg.live

ssh root@46.101.63.136
ssh -i /home/mukhtar/.ssh/id_rsa root@46.101.63.136